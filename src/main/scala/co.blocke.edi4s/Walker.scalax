package co.blocke.edi4s

import model.*
import scala.collection.mutable

object Walker:

  private def identifyGaps(source: List[String], target: List[String]): (List[String], List[String]) = {
    val inSourceOnly = source.filterNot(target.contains)
    val inTargetOnly = target.filterNot(source.contains)
    (inSourceOnly, inTargetOnly)
  }

  private def findSegmentPaths(
                                loop: RefinedLoopSpec,
                                currentPath: String,
                                map: mutable.LinkedHashMap[String, List[String]],
                                loopPrefix: String = ""
                              ): Unit = {
    val current = if loop.name == "HL" && loop.description.nonEmpty then s"HL[${loop.description}]" else loop.name
    val newPath = if loopPrefix.nonEmpty then s"$loopPrefix>$current" else s".$current"
    loop.body.foreach {
      case s: RefinedSegmentSpec =>
        val path = s"$currentPath$newPath.${s.name}"
        val existing = map.getOrElse(s.name, Nil)
        map.update(s.name, existing :+ path)
      case l: RefinedLoopSpec =>
        findSegmentPaths(l, currentPath + newPath, map, "") // body is same level
    }
    loop.nested.foreach(_.foreach { nestedLoop =>
      val nextPrefix = if loop.name == "HL" then s"$currentPath$newPath" else s"$currentPath$newPath."
      findSegmentPaths(nestedLoop, nextPrefix, map, if nestedLoop.name == "HL" then "" else loopPrefix)
    })
  }

  private def compareHLPaths(src: List[RefinedLoopSpec], tgt: List[RefinedLoopSpec]): Unit = {
    val srcMap = mutable.LinkedHashMap[String, List[String]]()
    val tgtMap = mutable.LinkedHashMap[String, List[String]]()

    src.foreach(findSegmentPaths(_, "", srcMap))
    tgt.foreach(findSegmentPaths(_, "", tgtMap))

    val srcOnly = srcMap.keySet.diff(tgtMap.keySet)
    val tgtOnly = tgtMap.keySet.diff(srcMap.keySet)
    val common = srcMap.keySet.intersect(tgtMap.keySet)

    srcOnly.foreach(s => srcMap(s).foreach(p => println(s"[GAP] Segment $p is missing in target")))
    tgtOnly.foreach(t => tgtMap(t).foreach(p => println(s"[GAP] Segment $p is missing in source")))
    common.foreach { name =>
      val srcPaths = srcMap(name)
      val tgtPaths = tgtMap(name)
      if srcPaths != tgtPaths then
        srcPaths.foreach(sp => println(s"[MOVED] Segment '$name' is at $sp in source but found at ${tgtPaths.mkString(", ")} in target"))
    }
  }

  def walkSegments(
                    path: String,
                    src: List[RefinedSegmentSpec | RefinedLoopSpec],
                    tgt: List[RefinedSegmentSpec | RefinedLoopSpec]
                  ): Unit = {
    val srcNames = src.map(nameOf)
    val tgtNames = tgt.map(nameOf)
    val (inSrcOnly, inTgtOnly) = identifyGaps(srcNames, tgtNames)

    inSrcOnly.foreach { name =>
      val foundPathsAtSameLevel = findSegmentInTree(name, tgt, path)
      if foundPathsAtSameLevel.nonEmpty then
        foundPathsAtSameLevel.foreach(tp => println(s"[GAP] Segment '$name' is at $path.$name in source but found at $tp in target"))
      else if path.split('.').exists(_.startsWith("HL")) then
        val fullSearchPaths = findSegmentInTree(name, tgt, "")
        if fullSearchPaths.nonEmpty then
          fullSearchPaths.foreach(tp => println(s"[MOVED] Segment '$name' is at $path.$name in source but found at $tp in target"))
        else
          println(s"[GAP] Segment $path.$name is missing in target")
      else
        println(s"[GAP] Segment $path.$name is missing in target")
    }

    inTgtOnly.foreach(name => println(s"[GAP] Segment $path.$name is missing in source"))

    srcNames.intersect(tgtNames).foreach { name =>
      val s = src.find(nameOf(_) == name).get
      val t = tgt.find(nameOf(_) == name).get
      val newPath = s"$path.${nameOf(s)}"
      (s, t) match {
        case (ss: RefinedSegmentSpec, ts: RefinedSegmentSpec) =>
          walkFields(newPath, ss.fields, ts.fields)

        case (sl: RefinedLoopSpec, tl: RefinedLoopSpec) =>
          walkFields(newPath, sl.fields, tl.fields)

          if sl.name == "HL" then
            compareHLPaths(List(sl), List(tl))
          else
            walkSegments(s"$newPath.body", sl.body, tl.body)

          val slNested = sl.nested.getOrElse(Nil)
          val tlNested = tl.nested.getOrElse(Nil)
          val slNames = slNested.map(nameOf)
          val tlNames = tlNested.map(nameOf)
          val (nestedSrcOnly, nestedTgtOnly) = identifyGaps(slNames, tlNames)

          nestedSrcOnly.foreach(n => println(s"[GAP] Nested loop $newPath>$n only in source"))
          nestedTgtOnly.foreach(n => println(s"[GAP] Nested loop $newPath>$n only in target"))

          slNames.intersect(tlNames).foreach { nestedName =>
            val sloop = slNested.find(nameOf(_) == nestedName).get
            val tloop = tlNested.find(nameOf(_) == nestedName).get
            walkSegments(s"$newPath.nested.$nestedName", List(sloop), List(tloop))
          }

        case _ =>
      }
    }
  }

  private def walkFields(
                          path: String,
                          src: List[RefinedSingleFieldSpec | RefinedCompositeFieldSpec],
                          tgt: List[RefinedSingleFieldSpec | RefinedCompositeFieldSpec]
                        ): Unit = {
    val srcNames = src.map(nameOfField)
    val tgtNames = tgt.map(nameOfField)
    val (inSrcOnly, inTgtOnly) = identifyGaps(srcNames, tgtNames)

    inSrcOnly.foreach(name => println(s"[GAP] Field $path.$name is missing in target"))
    inTgtOnly.foreach(name => println(s"[GAP] Field $path.$name is missing in source"))

    srcNames.intersect(tgtNames).foreach { name =>
      val s = src.find(n => nameOfField(n) == name).get
      val t = tgt.find(n => nameOfField(n) == name).get
      val newPath = s"$path.$name"

      (s, t) match {
        case (sc: RefinedCompositeFieldSpec, tc: RefinedCompositeFieldSpec) =>
          walkFields(newPath, sc.components, tc.components)
        case _ =>
      }
    }
  }

  private def nameOf(x: RefinedSegmentSpec | RefinedLoopSpec): String = x match {
    case s: RefinedSegmentSpec => s.name
    case l: RefinedLoopSpec    => l.name
  }

  private def nameOfField(x: RefinedSingleFieldSpec | RefinedCompositeFieldSpec): String = x match {
    case s: RefinedSingleFieldSpec     => s.name
    case c: RefinedCompositeFieldSpec => c.name
  }

  private def findSegmentInTree(
                                 name: String,
                                 tree: List[RefinedSegmentSpec | RefinedLoopSpec],
                                 path: String
                               ): List[String] = {
    tree.flatMap {
      case s: RefinedSegmentSpec if s.name == name =>
        List(s"$path.${s.name}")
      case _: RefinedSegmentSpec => Nil
      case l: RefinedLoopSpec =>
        val loopTag = if l.name == "HL" && l.description.nonEmpty then s"HL[${l.description}]" else l.name
        val bodyHits = findSegmentInTree(name, l.body, "").map(bh => (if path.isEmpty then s"$loopTag" else s"$path.$loopTag")+bh)
        val nestedHits = l.nested.map(_.flatMap(n => {
//          val current = if path.isEmpty then s".$loopTag" else s"$path>$loopTag"
//          val tag = if n.name == "HL" && n.description.nonEmpty then s"HL[${n.description}]" else n.name
//          findSegmentInTree(name, n.body, s"$current>$tag")
          findSegmentInTree(name, n.body, "")
        })).getOrElse(Nil).map(nh => (if path.isEmpty then s"$loopTag" else s"$path>$loopTag")+nh)
        bodyHits ++ nestedHits
    }
  }
  /*
  private def findSegmentInTree(
                                 name: String,
                                 tree: List[RefinedSegmentSpec | RefinedLoopSpec],
                                 path: String
                               ): List[String] = {
    tree.flatMap {
      case s: RefinedSegmentSpec if s.name == name =>
        List(s"$path.${s.name}")
      case _: RefinedSegmentSpec => Nil
      case l: RefinedLoopSpec =>
        val loopTag = if l.name == "HL" && l.description.nonEmpty then hlDescription(l.description) else l.name
        val current = if path.isEmpty then s".$loopTag" else s"$path.$loopTag"
        val bodyHits = findSegmentInTree(name, l.body, current)
        val nestedHits = l.nested.map(_.flatMap(n => {
          val tag = if n.name == "HL" && n.description.nonEmpty then hlDescription(n.description) else n.name
          findSegmentInTree(name, n.body, s"$current>$tag")
        })).getOrElse(Nil)
        bodyHits ++ nestedHits
    }
  }
  */

  private inline def hlDescription(desc: String): String = if desc == "" then "HL" else s"HL[${desc}]"
