package co.blocke.edi4s

import co.blocke.edi4s.CanonicalParser.show
import zio.*
import zio.nio.file.{Files, Path}
import model.*
import tokenizer.*
import table.*

import java.io.FileNotFoundException

/*
Key takeaways:
	‚Ä¢	**: A field is missing, but it‚Äôs not the last one. There are other fields following it, so it‚Äôs essentially a ‚Äúgap‚Äù where a value should have been but wasn‚Äôt provided.
	‚Ä¢	*~: A field is present but empty. It‚Äôs in the data, but there‚Äôs no value between the delimiters.
	‚Ä¢	~~: The last field in the segment is missing. This could happen if the last field in the segment is omitted entirely.
*/

object Main extends ZIOAppDefault {

  import CanonicalParser.given


  def loadCanonicalSpec(path: String, topLevel: String, document: String, version: String, partner: String): ZIO[Any, CanonicalError, RefinedDocumentSpec] =
    val filePath = Path(path)
    for {
      lines <- Files.readAllLines(filePath).mapError{
        case ioe: Throwable => CanonicalError("Can't read file: "+ioe.getMessage)
      }
      edi <- CanonicalParser.readSpec(lines.mkString("\n"))
      refined <- CanonicalParser.toRefined(edi, topLevel, document, version, partner)
    } yield refined

  def loadRefinedSpec(path: String): ZIO[Any, CanonicalError, RefinedDocumentSpec] =
    val filePath = Path(path)
    for {
      lines <- Files.readAllLines(filePath).mapError{
        case ioe: Throwable => CanonicalError("Can't read file: "+ioe.getMessage)
      }
      refined = sjRefinedSpec.fromJson(lines.mkString("\n"))
    } yield refined

  def run: ZIO[ZIOAppArgs & Scope, CanonicalError, Unit] = {
    
    for {
//      foo <- loadCanonicalSpec("specs/canonical/doc856_v4030.json", "TS856", "850", "4030", "ANSI")
//      _ <- ZIO.succeed(println(sjRefinedSpec.toJson(foo)))

      /* Un-comment to do a comparison run
      */

      std <- loadRefinedSpec("specs/x12_856_5010.json")
      src <- loadRefinedSpec("specs/tf_856_5010.json")
      pfg <- loadRefinedSpec("specs/pfg_856_5010.json")
      tj <- loadRefinedSpec("specs/tj_856_4030.json")
      cm <- loadRefinedSpec("specs/cm_856_5010.json")


      table1 = diffReport("Taylor Farms", "Core-Mark", src, std, cm)
      table2 = diffReport("Taylor Farms", "PFG", src, std, pfg)
      table3 = diffReport("Taylor Farms", "Trader Joe's", src, std, tj)

      _ <- ZIO.succeed(println(table1.toString))
      _ <- ZIO.succeed(println(table2.toString))
      _ <- ZIO.succeed(println(table3.toString))


      /*
      _ <- ZIO.succeed{
        val foo = result.map(_ match {
          case s: LoopSegmentDifference =>
//            if s.bodyDiff.isDefined then
//              s.bodyDiff.get.map(d => s.canonicalName+"."+d.path+"*"+d.canonicalName)
            if s.nested.isDefined then
              s.nested.get.map(n => s.canonicalName+"."+n.path+"&"+n.canonicalName)
            else List(s.path.toString+"."+s.canonicalName)
          case s: SimpleSegmentDifference =>
            List(s.path.toString+"*"+s.canonicalName)
          case _ => List("unknown")
        })
        println(foo.flatten.mkString("\n"))
      }
      */

    } yield ()
  }

  def diffReport(
                  srcPartner: String,
                  targetPartner: String,
                  src: RefinedDocumentSpec,
                  edi: RefinedDocumentSpec,
                  target: RefinedDocumentSpec,
                  filterUnused: Boolean = true
                ): Table =
    val result = DiffEngine.compareSpecs(src, edi, target)
    val titles = List(
      Title(List(Cell("üì¶ EDI Segment Comparison Report"))),
      Title(List(Cell(s"$srcPartner -to- $targetPartner")))
    )
    val header = Header(List(
      Cell(s"Source ($srcPartner)"),
      Cell("Difference"),
      Cell(s"Target ($targetPartner)"),
      Cell("Difference")
    ))
    val rawRows = result.foldLeft(List.empty[BodyRow]) { case (acc, diff) => acc ++ diff.render() }
    val rows = if filterUnused then
      rawRows.filter { row =>
        // keep rows that have at least one cell *not* muted
        row.cells.exists(cell => !cell.style.contains(Style.MUTED))
      }
    else rawRows
    Table(
      title = titles,
      columns = 4,
      columnWidthPct = List(35, 15, 35, 15),
      tableWidth = 200,
      header,
      rows
    )
}

  /*
  val sampleEDI1 = "ST*855*0001*0002*4010~"
  // All fields are present and populated.
  // Field 1: "855", Field 2: "0001", Field 3: "0002", Field 4: "4010"

  val sampleEDI2 = "ST*855*0001**4010~"
  // Field 1: "855", Field 2: "0001", Field 3: missing (**), Field 4: "4010"

  val sampleEDI3 = "ST*855****4010~"
  // Field 1: "855", Field 2: "0001", Fields 3 and 4 are missing (**), Field 5: "4010"

  val sampleEDI4 = "ST*855*0001~"
  // Field 1: "855", Field 2: "0001", Field 3 and 4 truncated (missing)

  val sampleEDI5 = "ST*855*a:b:c**x~" // composite

  val sampleEDI6 = "ST*855*Foo\\*Bar\\:Blah\\~*x~"  // escape

  val sampleEDI7 = "ZZ*855*0001**4010~"
  val sampleEDI8 = "ZZ*855*0001~"

  val sampleEDI9 = "ST**0001*0002*4010~"

  val sampleEDI10 =
    """REF*IA*TF-12345~
      |REF*IV*SO-9876~
      |HL*1**S~
      |HL*2*1*I~
      |LIN**CH*US~
      |SN1**168*EA~
      |HL*3*1*I~
      |LIN**CH*CN~
      |SN1**99*EA~""".stripMargin
    //"ST*855*0001*0002*4010~\n  ST*855*a:b:c**x~"

  // Start the loop
  def run = {
    val tests = List(
      sampleEDI1,
      sampleEDI2,
      sampleEDI3,
      sampleEDI4,
      sampleEDI5,
      sampleEDI6,
      sampleEDI7,
      sampleEDI8,
      sampleEDI9,
      sampleEDI10
    )

    ZIO.foreach(tests){ txt =>
      println(txt)
      val tokenizerContext = TokenizerContext(doc = txt,offset = 0, config = TokenizerConfig())
      X12Tokenizer.tokenize(tokenizerContext).flatMap((result, nextPc) => ZIO.succeed(println("   >>> "+result+"\n")))
    }
*/
