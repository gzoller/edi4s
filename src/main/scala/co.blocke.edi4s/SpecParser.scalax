package co.blocke.edi4s

import model.*
import zio.*

import scala.annotation.tailrec

case class SpecError(msg:String = "")

case class SpecContext( spec: List[String], tabPos: Int = 0, lineNum: Int = 1, soFar: Option[Specification] = None):
  def done: Boolean = spec.isEmpty
  def tabLevel: Int = if done then -1 else
    var i = 0
    while i < spec.head.length && spec.head.charAt(i).isWhitespace || spec.head.charAt(i) == '-' do i += 1
    i
  def lookAhead(token: String, tabLevel: Int): Boolean =
    val cleaned = this.consumeEmptyLines
    if !cleaned.done then cleaned.spec.head.replaceFirst("-", " ").startsWith( ((" "*tabLevel)+token) ) else false
  def consumeEmptyLines: SpecContext =
    if !done && (spec.head.trim == "" || spec.head.trim.startsWith("#")) then
      this.copy(spec = spec.tail, lineNum = lineNum+1).consumeEmptyLines
    else
      this

object SpecParser:

  def parseSpec( specLines: List[String] ): ZIO[Any, SpecError, List[Specification]] =
    def loop( sc: SpecContext, acc: List[Specification] ): ZIO[Any, SpecError, (SpecContext, List[Specification])] =
      if sc.done then
        ZIO.succeed((sc, acc))
      else
        val skipWS = sc.consumeEmptyLines
        for {
          (newSc, seg) <- parseSegmentSpec(skipWS, skipWS.tabLevel)
          result <- loop(newSc, seg :: acc)
        } yield result

    for {
      // Start the recursive loop with the initial offset and an empty StringBuilder.
      result <- loop(SpecContext(specLines), Nil)
      (_, specs) = result
    } yield specs.reverse

  @tailrec
  private def parseLines(ctx: SpecContext, tabLevel: Int, tokens: List[String], values: Map[String, String] = Map.empty[String, String]): ZIO[Any, SpecError, (SpecContext, List[String], Map[String, String])] =
    if tokens == Nil then
      ZIO.succeed((ctx, Nil, values))
    else
      val lines = ctx.consumeEmptyLines
      lines.spec match {
        case Nil => ZIO.fail(SpecError()) // unexpected end of content
        case line :: rest =>
          val regex = s"""^([ -]*?)${tokens.head}:\\s*(.*?)\\s*(?:#.*)?$$""".r
          line match {
            case regex(tabLead, value) =>
              if tabLead.length != tabLevel then
                ZIO.fail(SpecError()) // wrong tab level
              parseLines(ctx.copy(rest, lineNum = ctx.lineNum+1), tabLevel, tokens.tail, values + (tokens.head -> value))
            case _ =>
              ZIO.fail(SpecError(s"Line ${ctx.lineNum}: Expected token ${tokens.head} was not found.")) // expected token but wasn't found
          }
      }

  private def parseFields( sc: SpecContext, tabLevel: Int, acc: List[FieldSpec] ): ZIO[Any, SpecError, (SpecContext, List[FieldSpec])] =
    if sc.lookAhead("Name", tabLevel) then
      for {
        (nextSc, _, values) <- parseLines(sc, tabLevel, List("Name", "FriendlyName", "Description", "EdiType", "IsRequired"))
        nextAcc = FieldSpec(
          values("Name"),
          values("FriendlyName"),
          values("Description"),
          values("EdiType"),
          values("IsRequired").toBoolean
        ) :: acc
        result <- parseFields(nextSc, tabLevel, nextAcc)
      } yield result
    else
      ZIO.succeed((sc, acc.reverse))

  private def parseSegmentSpec(sc: SpecContext, tabLevel: Int): ZIO[Any, SpecError, (SpecContext, Specification)] =
    if !sc.spec.head.startsWith((" " * tabLevel) + "===") then
      ZIO.fail(SpecError()) // expected ==== line
    for  {
      (nextSc, _, values) <- parseLines(sc.copy(spec = sc.spec.tail, lineNum = sc.lineNum+1), tabLevel, List("Segment","FriendlyName","Description","IsRequired","Fields"))
      (nextSc2, fields) <- parseFields(nextSc, tabLevel+4, Nil)
      seg = SegmentSpec(
        values("Segment"),
        values("FriendlyName"),
        values("Description"),
        values("IsRequired").toBoolean,
        fields
      )
      // Peek ahead and see if this is a loop
      result <- if nextSc2.lookAhead("Loop", tabLevel) then parseLoopSpec(nextSc2, tabLevel, seg) else ZIO.succeed((nextSc2, seg))
    } yield result

  private def parseBodySegments(ctx: SpecContext, tabLevel: Int, acc: List[Specification]): ZIO[Any, SpecError, (SpecContext, List[Specification])] =
    val skipWS = ctx.consumeEmptyLines
    if (skipWS.tabLevel == tabLevel) {
      for {
        (nextCtx, value) <- parseSegmentSpec(skipWS, tabLevel)
        result <- parseBodySegments(nextCtx, tabLevel, value :: acc)
      } yield result
    } else {
      ZIO.succeed((skipWS, acc.reverse))
    }

  private def parseLoopSpec(sc: SpecContext, tabLevel: Int, seg: SegmentSpec): ZIO[Any, SpecError, (SpecContext, Specification)] =
    for {
      (nextSc, _, _) <- parseLines(sc, tabLevel, List("Loop")) // consume Loop: at this tab level
      (nextSc2, _, values) <- parseLines(nextSc, tabLevel+2, List("MinOccurs","MaxOccurs","Body"))
      (nextSc3, bodySegs) <- parseBodySegments(nextSc2, tabLevel+4, Nil)
      loop = LoopSegmentSpec.apply(seg, values("MinOccurs").toInt, values("MaxOccurs").toInt, bodySegs)
    } yield (nextSc3, loop)

