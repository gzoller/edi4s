package co.blocke.edi4s
package model

case class FieldSpec(
      name: String,
      friendlyName: String,
      description: String,
      ediType: String,
      isRequired: Boolean
      ):
      override def toString: String =
            s"Field: $name ($friendlyName) - $ediType req $isRequired"

sealed trait Specification:
      val name: String
      val friendlyName: String
      val description: String
      val isRequired: Boolean
      val fields: List[FieldSpec]
      def show(tab:Int=0): String =
            s"${" "*tab*3}Segment: $name ($friendlyName) req: $isRequired\n"+
            s"${" "*tab*3}   $description\n" +
            s"${" "*tab*3}   Fields:\n" +
              fields.map(f => f.toString).map(fs => s"${" "*tab*3}      $fs").mkString("\n")

case class SegmentSpec(
      name: String,
      friendlyName: String,
      description: String,
      isRequired: Boolean,
      fields: List[FieldSpec]
      ) extends Specification

case class LoopSegmentSpec(
      name: String,
      friendlyName: String,
      description: String,
      isRequired: Boolean,
      fields: List[FieldSpec],
      minOccurs: Int,
      maxOccurs: Int,
      body: List[Specification],
      isHL: Boolean
      ) extends Specification:
      override def show(tab:Int): String =
            super.show(tab) + s"""\n${" "*tab*3}   Body:  (is HL loop? $isHL)\n""" +
              body.map(b => b.show(tab+2)).mkString("\n") +
              s"\n${" "*tab*3}   (end body $name)\n"

object LoopSegmentSpec:
      def apply( ss: SegmentSpec, minOccurs: Int, maxOccurs: Int, body: List[Specification] ): LoopSegmentSpec =
            LoopSegmentSpec(ss.name, ss.friendlyName, ss.description, ss.isRequired, ss.fields, minOccurs, maxOccurs, body, ss.name == "HL")