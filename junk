package co.blocke.edi4s
package table

case class TextRenderer(table: Table) extends Renderer:
  private val RESET = "\u001b[0m"

  def render(): String =
    val sb = new StringBuilder
    val widths = normalizedColumnWidths
    val decimalAlignedCellOffsets = findDecimalAlignedCells

    table.title.foreach(t => sb.append(renderTitle(t, widths)))
    sb.append(renderDivider(widths, '='))
    sb.append(renderRow(table.header, widths, decimalAlignedCellOffsets))
    sb.append(renderDivider(widths, '='))

    val rowCount = table.rows.length
    table.rows.zipWithIndex.foreach {
      case (r: SubHeader, i) =>
        if i > 0 && !isSubHeader(table.rows(i - 1)) then
          sb.append(renderDivider(widths))
        sb.append(renderRow(r, widths, decimalAlignedCellOffsets))
        sb.append(renderDivider(widths))
      case (r: Row, i) =>
        sb.append(renderRow(r, widths, decimalAlignedCellOffsets))
        if i == table.rows.length - 1 then
          sb.append(renderDivider(widths))
    }
    sb.toString

  private def isSubHeader(r: BodyRow): Boolean =
    r match
      case _: SubHeader => true
      case _            => false

  private def findDecimalAlignedCells: List[(Int, Int)] =
    val allRows = table.header +: table.rows
    val columnCount = table.columnWidthPct.length

    (0 until columnCount).flatMap { colIdx =>
      var maxRightOfDecimal = 0
      allRows.foreach { row =>
        if colIdx < row.cells.length then
          val cell = row.cells(colIdx)
          val alignment = effectiveAlign(cell, row.align)
          if alignment == Align.DECIMAL then
            val content = cell.content.trim
            val parts = content.split("\\.")
            if parts.length == 2 then
              val rightDigits = parts(1).length
              maxRightOfDecimal = math.max(maxRightOfDecimal, rightDigits)
      }
      if maxRightOfDecimal > 0 then
        Some(colIdx -> maxRightOfDecimal)
      else None
    }.toList

  def normalizedColumnWidths: List[Int] =
    val totalPct = table.columnWidthPct.sum
    table.columnWidthPct.map(p => (p.toDouble / totalPct * table.tableWidth).toInt)

  def effectiveStyle(style: Style): String =
    table.styleMap.getOrElse("text", Map()).getOrElse(style, "")

  def effectiveAlign(cell: Cell, rowAlign: Align): Align =
    cell.align.getOrElse(rowAlign)

  private def renderTitle(title: Title, widths: List[Int]): String =
    val totalWidth = widths.sum + widths.length + 1
    val content = title.cells.head.content
    val pad = (totalWidth - content.length) / 2
    " " * pad + content + "\n"

  private def renderDivider(widths: List[Int], char: Char = '-'): String =
    widths.map(w => "+" + char.toString * w).mkString + "+\n"

  private def padDecimal(content: String, width: Int, rightOffset: Int): String =
    val stripped = content.trim
    val (intP, fracP) =
      if stripped.contains(".") then
        val parts = stripped.split("\\.")
        (parts(0), parts(1))
      else
        (stripped, "")
    val totalLength = intP.length + (if fracP.nonEmpty then 1 + fracP.length else 0)
    val padLeft = width - (rightOffset + totalLength)
    val padRight = width - (padLeft + totalLength)
    " " * padLeft + intP + (if fracP.nonEmpty then "." + fracP else "") + " " * padRight

  private def pad(content: String, width: Int, align: Align): String =
    align match
      case Align.LEFT    => content.padTo(width, ' ')
      case Align.CENTER  =>
        val padLeft = (width - content.length) / 2
        val padRight = width - content.length - padLeft
        " " * padLeft + content + " " * padRight
      case Align.RIGHT   => " " * (width - content.length) + content
      case Align.DECIMAL => pad(content, width, Align.RIGHT) // fallback if no offset known

  private def renderRow(row: TableRow, widths: List[Int], decimalAlignOffsets: List[(Int, Int)]): String =
    val sb = new StringBuilder
    sb.append("|")

    var i = 0
    val totalCols = widths.length
    while (i < row.cells.length) {
      val c = row.cells(i)
      val span = math.max(1, c.colspan)
      val spanWidth = widths.slice(i, i + span).sum + (span - 1)
      val styleStr = c.style.map(effectiveStyle).getOrElse(effectiveStyle(row.style))
      val align = effectiveAlign(c, row.align)
      val content = " " * (c.indent * 2) + c.content
      val finalPad = align match
        case Align.DECIMAL =>
          decimalAlignOffsets.find(_._1 == i) match
            case Some((_, offset)) => padDecimal(content, spanWidth, offset)
            case None              => pad(content, spanWidth, align)
        case _ => pad(content, spanWidth, align)
      sb.append(styleStr).append(finalPad).append(RESET).append("|")
      i += span
    }

    sb.append("\n")
    sb.toString
